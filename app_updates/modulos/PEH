import pandas as pd
import numpy as np
import os
from typing import Optional

def run_ncp_peh(input_file_path: str, ruta_salida_dat: str, dest_date: Optional[str] = None):
    """
    Procesa la hoja 'PEH' del archivo data.xlsx (desde 'data_path_comun')
    y genera el archivo Hydro_bids.dat en 'ruta_salida_dat' (formato Wide Format por hora), 
    siguiendo el estilo Archivo_NCP_PEH.

    Parámetros:
    data_path_comun (str): La ruta al directorio que contiene el archivo data.xlsx.
    ruta_salida_dat (str): La ruta al directorio donde se guardará Hydro_bids.dat.
    dest_date (str, opcional): La fecha de destino.
    """
    # --- CONFIGURACIÓN CON PARÁMETROS DE ENTRADA ---
    
    input_sheet_name = 'PEH' # <--- Nombre de la hoja de Excel
    output_file_name = 'Hydro_bids.dat'
    
    # Construcción de rutas de entrada y salida
    full_input_path = input_file_path
    full_output_path = os.path.join(ruta_salida_dat, output_file_name)
    
    print(f"Buscando archivo de ENTRADA en: {full_input_path}")
    print(f"Leyendo hoja: {input_sheet_name}")
    print(f"Ruta de SALIDA esperada: {full_output_path}")

    chunk_size = 10000 
    NA_REPLACEMENT_VALUE = '0' 

    print(f"--- INICIO DEL PROCESO DE CONVERSIÓN (Archivo_NCP_PEH - Fuente: {full_input_path}/{input_sheet_name}) ---")

    # 1. Lectura del archivo EXCEL
    print(f"\n1. Intentando leer la hoja '{input_sheet_name}' del archivo '{full_input_path}'...")
    try:
        # Usamos pd.read_excel en lugar de pd.read_csv
        df = pd.read_excel(full_input_path, sheet_name=input_sheet_name)
        print(f"   -> Lectura exitosa de la hoja '{input_sheet_name}'.")
    except FileNotFoundError:
        print(f"   -> ERROR: Archivo '{full_input_path}' no encontrado.")
        raise FileNotFoundError(f"Archivo '{full_input_path}' no encontrado.")
    except ValueError as e:
        # Este error ocurre si la hoja no existe
        print(f"   -> ERROR: Hoja '{input_sheet_name}' no encontrada en el archivo. {e}")
        raise ValueError(f"Hoja '{input_sheet_name}' no encontrada en el archivo: {full_input_path}")
    except Exception as e:
        print(f"   -> ERROR al leer el archivo Excel: {e}")
        raise Exception(f"Error al leer el archivo Excel: {e}")

    print(f"   -> Filas leídas: {len(df):,}")


    # 2. Limpieza de columnas y preparación de la hora/fecha
    print("\n2. Limpieza y preparación de datos de tiempo y formato ancho...")
    
    # Mapeo de los nombres de columna del nuevo archivo a nombres estándar
    NEW_COLUMN_MAPPING = {
        '!dd': 'DIA', 
        'mm': 'MES', 
        'aaaa': 'ANIO', 
        'hh': 'HORA', 
        'mm.1': 'MINUTO', 
        'level': 'NIVEL'
    }
    
    # Columnas de tiempo finales
    time_cols_final = ['DIA', 'MES', 'ANIO', 'HORA', 'MINUTO', 'NIVEL']

    # Aplicar limpieza de encabezados (mejorada)
    df.columns = (df.columns
                  .astype(str) # Convertir a str por si pandas lee encabezados como números/objetos
                  .str.strip('\'"') 
                  .str.strip())       
    
    df.rename(columns=NEW_COLUMN_MAPPING, inplace=True)

    # Conversión y limpieza de las columnas de tiempo
    for col in time_cols_final:
        df[col] = pd.to_numeric(df[col], errors='coerce').astype('Int64')

    df.dropna(subset=time_cols_final, inplace=True)

    # Identificar las columnas de datos
    data_cols = df.columns.drop(time_cols_final)

    # Convertir columnas de datos a numérico
    for col in data_cols:
        df[col] = pd.to_numeric(df[col], errors='coerce')

    df_final = df[time_cols_final + data_cols.tolist()].copy()
    
    # Función de formateo de línea (versión simplificada de CSV)
    def format_final_line_ncp(row, data_cols):
        # Aseguramos enteros para el tiempo
        time_part = f"{int(row['DIA']):02d},{int(row['MES']):02d},{int(row['ANIO'])},{int(row['HORA']):02d},{int(row['MINUTO']):02d},{int(row['NIVEL'])}"
        
        # Parte de datos
        data_parts = []
        for col in data_cols:
            val = row[col]
            if pd.isna(val):
                data_parts.append(NA_REPLACEMENT_VALUE)
            else:
                data_string = f"{val:.4f}".rstrip('0').rstrip('.')
                data_parts.append(data_string)

        data_part = ",".join(data_parts)
        return f"{time_part},{data_part}"

    # Aplicar la función a todas las filas
    df_final['DAT_LINE'] = df_final.apply(lambda row: format_final_line_ncp(row, data_cols), axis=1)

    total_lines = len(df_final)
    print(f"   -> Líneas de datos listas para escribir: {total_lines:,}")


    # 3. Guardar en el archivo Hydro_bids.dat
    print(f"\n3. Iniciando la escritura en '{full_output_path}'...")
    
    # Preparar el encabezado para el formato Archivo_NCP_PEH
    official_header_time_cols = ['!dd', 'mm', 'aaaa', 'hh', 'mm', 'level']
    header_cols = official_header_time_cols + data_cols.tolist()
    header = [",".join(header_cols)]

    data_lines = df_final['DAT_LINE'].tolist()

    try:
        # Asegurarse de que el directorio de salida exista
        os.makedirs(ruta_salida_dat, exist_ok=True)
        
        # Escribir usando la ruta de salida completa
        with open(full_output_path, 'w') as f:
            f.write(header[0] + '\n')
            lines_written = 0

            for i in range(0, total_lines, chunk_size):
                chunk = data_lines[i:i + chunk_size]
                f.write('\n'.join(chunk) + '\n')
                lines_written += len(chunk)
    except Exception as e:
        print(f"   -> ERROR al escribir el archivo '{full_output_path}': {e}")
        raise Exception(f"Error al escribir el archivo de salida: {e}")

    print(f"\n--- PROCESO Archivo_NCP_PEH COMPLETADO ---")
    print(f"El archivo '{output_file_name}' ha sido creado con éxito en: {ruta_salida_dat}")

if __name__ == "__main__":
    # --- EJEMPLO DE USO Y GENERACIÓN DE DATOS DE PRUEBA ---
    from datetime import date, timedelta
    
    TEST_DATA_PATH = "./test_data_in_excel"
    TEST_OUTPUT_PATH = "./test_data_out_excel"
    os.makedirs(TEST_DATA_PATH, exist_ok=True)
    os.makedirs(TEST_OUTPUT_PATH, exist_ok=True)
    
    # Generar data.xlsx con la hoja PEH
    test_data = {
        '!dd': [1, 2],
        'mm': [10, 10],
        'aaaa': [2023, 2023],
        'hh': [1, 2],
        'mm.1': [0, 0],
        'level': [1, 1],
        "UnidadA": [50.5, 60.3],
        "UnidadB": [70.0, np.nan]
    }
    df_test = pd.DataFrame(test_data)
    
    # Usar ExcelWriter para guardar la hoja PEH
    excel_path = os.path.join(TEST_DATA_PATH, "data.xlsx")
    with pd.ExcelWriter(excel_path, engine='xlsxwriter') as writer:
        df_test.to_excel(writer, sheet_name='PEH', index=False)
        
    print(f"Archivo de prueba 'data.xlsx' con hoja 'PEH' creado en: {TEST_DATA_PATH}")
    
    try:
        # Llamada a la función con los argumentos de prueba (DEST_DATE de mañana)
        DEST_DATE = (date.today() + timedelta(days=1)).strftime("%Y-%m-%d")
        run_ncp_peh(TEST_DATA_PATH, TEST_OUTPUT_PATH, DEST_DATE)
    except Exception as e:
        print(f"Error durante la ejecución del módulo independiente PEH: {e}")
