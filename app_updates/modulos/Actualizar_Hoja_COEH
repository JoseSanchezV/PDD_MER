import pandas as pd
import numpy as np
import os
import shutil
import datetime
from typing import Dict, Any, List
from openpyxl import load_workbook 

# --- CONSTANTES ---
LDM_INPUT_FILENAME = "LDM.xlsx"
COTAS_INPUT_FILENAME = "Cotas Actualizadas.csv"
COTAS_OUTPUT_FILENAME = "Cotas Actualizadas.csv" 
PDD_EXCEL_FILENAME = "data.xlsx" 

SHEET_BASE_COEH = "BASE COEH"
SHEET_COEH = "COEH" 

# Columnas en los archivos fuente
COL_LDM_BASE_COEH_IDX = 0  # Generador LDM (Columna A en BASE COEH)
COL_NCP_BASE_COEH_IDX = 1  # Nemotécnico NCP (Columna B en BASE COEH)

# CORRECCIÓN: La columna de precio es siempre la D (índice 3), independientemente de la banda.
COL_LDM_PRECIO_IDX = 3 
COL_LDM_NEMO_IDX = 0 # El nemotécnico es la columna A (índice 0)

# Rangos de hora INCLUSIVOS
BANDA_HORARIA_RANGES = {
    'MINIMA': [(0, 5), (22, 23)], 
    'MEDIA': [(6, 17)], 
    'MAXIMA': [(18, 21)] 
}

# --- FUNCIONES AUXILIARES ---

def clean_nemotecnico(nemotecnico: Any) -> str:
    """Limpia el nemotécnico quitando espacios, comillas simples y comillas dobles."""
    if pd.isna(nemotecnico) or nemotecnico is None:
        return ""
    nemotecnico = str(nemotecnico).strip()
    nemotecnico = nemotecnico.replace("'", "")
    nemotecnico = nemotecnico.replace('"', "")
    return nemotecnico

def create_nemotecnico_map(df_base_coeh: pd.DataFrame) -> Dict[str, str]:
    """Crea un mapeo de {Nemotécnico_NCP (Col B): Generador_LDM (Col A)}."""
    df_map = df_base_coeh.iloc[:, [COL_LDM_BASE_COEH_IDX, COL_NCP_BASE_COEH_IDX]].copy()
    
    df_map.iloc[:, 1] = df_map.iloc[:, 1].apply(clean_nemotecnico)
    df_map.iloc[:, 0] = df_map.iloc[:, 0].apply(clean_nemotecnico)
    
    nemotecnico_map = dict(zip(df_map.iloc[:, COL_NCP_BASE_COEH_IDX], df_map.iloc[:, COL_LDM_BASE_COEH_IDX]))
    nemotecnico_map = {k: v for k, v in nemotecnico_map.items() if k}
    
    return nemotecnico_map

# --- FUNCIÓN PRINCIPAL DE CONVERSIÓN ---

def run_actualizar_hoja_coeh(
    data_path_comun: str, 
    archivo_principal_path: str, 
    ruta_salida_dat: str, 
    dest_date: str, 
    ldm_file_path: str 
) -> bool:
    """
    Implementa la lógica FormatoCOEH, corrigiendo la búsqueda de precios por bloques 
    de filas dinámicos en LDM.xlsx y la asignación horaria en COEH.
    """
    print("--- INICIO DE PROCESO: ACTUALIZACIÓN DE HOJA COEH  -----")
    
    num_time_cols = 6 
    s_cotas_path_origen = os.path.join(data_path_comun, COTAS_INPUT_FILENAME) 


    try:
        # --- CÁLCULO DINÁMICO DEL NOMBRE DE LA HOJA LDM y FECHA DE FILTRADO ---
        try:
            date_obj = datetime.datetime.strptime(dest_date, '%d/%m/%Y')
            dia_str = date_obj.strftime('%d')
            mes_str = date_obj.strftime('%m')
            anio_str = date_obj.strftime('%Y')
            sheet_ldm_name_dynamic = f"Dia{dia_str}" 
        except ValueError:
            raise ValueError(f"Formato de fecha inválido '{dest_date}'. Se espera DD/MM/YYYY.")

        print(f"Buscando hoja dinámica LDM: '{sheet_ldm_name_dynamic}'")

        # --- 1. Lectura de Archivos (Manejando Fallbacks de entorno) ---
        
        # 1.1 Cargar BASE COEH y COEH
        try:
            df_base_coeh = pd.read_excel(archivo_principal_path, sheet_name=SHEET_BASE_COEH, header=None, skiprows=1) 
            xls_data = pd.ExcelFile(archivo_principal_path, engine='openpyxl')
            df_coeh_full = pd.read_excel(xls_data, sheet_name=SHEET_COEH, header=None, nrows=2)
            df_coeh_data = pd.read_excel(xls_data, sheet_name=SHEET_COEH, header=None, skiprows=2)
        except Exception:
           # Fallback para pruebas con archivos CSV simulados
            df_base_coeh = pd.read_csv("Data.xlsx - BASE COEH.csv", header=None, skiprows=1)
            df_coeh_full = pd.read_csv("Data.xlsx - COEH.csv", header=None, nrows=2)
            df_coeh_data = pd.read_csv("Data.xlsx - COEH.csv", header=None, skiprows=2)

        # Construcción del Encabezado Final (Corrección de encabezado mantenida)
        nemotecnicos_unidad = df_coeh_full.iloc[0, num_time_cols:].tolist() 
        encabezado_tiempo = df_coeh_full.iloc[1, :num_time_cols].tolist() 
        encabezado_final = encabezado_tiempo + nemotecnicos_unidad
        df_coeh_update = df_coeh_data.copy() 
        df_coeh_update.columns = encabezado_final 
        df_coeh_update = df_coeh_update.reset_index(drop=True)
        print("Lectura inicial de archivos completada. Hoja COEH alineada a nemotécnicos.")

        # Extraemos los nombres LIMPIOS para el filtrado (ej: 'dd', 'mm', 'aaaa', 'hh')
        COL_DIA_NAME = df_coeh_update.columns[0]
        COL_MES_NAME = df_coeh_update.columns[1]
        COL_ANIO_NAME = df_coeh_update.columns[2]
        COL_HOUR_NAME = df_coeh_update.columns[3]

        df_coeh_update = df_coeh_update.reset_index(drop=True)
        
        # --- 1.2 CORRECCIÓN CRÍTICA DE CARGA LDM: Cargar por bloques ---
        
        # Leemos el archivo LDM desde la fila 7 (header=6). 
        # Cargamos unas ~450 filas para asegurar la captura de los 3 bloques.
        try:
            # Intentar leer Excel real
            df_ldm_full = pd.read_excel(ldm_file_path, sheet_name=sheet_ldm_name_dynamic, header=6, nrows=600)
        except Exception:
            # Fallback para archivos CSV (con encabezado modificado por el entorno)
            df_ldm_full = pd.read_csv(f"LDM.xlsx - {sheet_ldm_name_dynamic}.csv", header=6, nrows=600)

        # --- 2. Determinación de Mapeos LDM (Lógica de Segmentación Dinámica) ---

        col_nemotecnico_ldm = df_ldm_full.columns[COL_LDM_NEMO_IDX] 
        nemotecnico_map = create_nemotecnico_map(df_base_coeh)

        # 2.1 LÓGICA DINÁMICA: Identificar el número de unidades en el primer bloque.
        # Esto asume que el nemotécnico se repite en el segundo bloque inmediatamente.
        # Usamos df.dropna(subset=[col_nemotecnico_ldm]) para omitir filas de texto entre bloques.
        df_ldm_clean = df_ldm_full.dropna(subset=[col_nemotecnico_ldm]).copy()
        
        # El número de unidades es la longitud de la lista de nemotécnicos únicos en el primer bloque
        # o el conteo hasta que el primer nemotécnico (ej. 'BVT-B') se repita.
        # Una heurística más simple y robusta es asumir que el tamaño del bloque es 1/3 del total de nemotécnicos válidos.
        all_nemos = df_ldm_clean[col_nemotecnico_ldm].apply(clean_nemotecnico).tolist()
        
        # Buscar el punto de inicio del segundo bloque, que es donde el primer nemotécnico se repite.
        try:
            first_nemo = all_nemos[0]
            # Encontrar el índice donde el primer nemotécnico (o el siguiente) se repite por segunda vez.
            num_units = all_nemos[1:].index(first_nemo) + 1 
        except Exception:
            # Si solo hay un bloque o es muy pequeño
            num_units = len(all_nemos) // 3 if len(all_nemos) >= 3 else len(all_nemos)
            
        print(f"Unidades estimadas por bloque (dinámico): {num_units}")

        # 2.2 Separación de los 3 bloques por índice (usando el índice del DataFrame limpio)
        df_ldm_min = df_ldm_clean.iloc[num_units:num_units*2, :].copy() 
        df_ldm_med = df_ldm_clean.iloc[num_units*2:num_units*3, :].copy()
        df_ldm_max = df_ldm_clean.iloc[num_units*3:num_units*4, :].copy()

        # 2.3 Generar los 3 diccionarios de precios de LDM (usando la Columna D (índice 3))
        ldm_map_min = dict(zip(
            df_ldm_min[col_nemotecnico_ldm].apply(clean_nemotecnico), 
            pd.to_numeric(df_ldm_min.iloc[:, COL_LDM_PRECIO_IDX], errors='coerce').fillna(0) 
        ))
        ldm_map_med = dict(zip(
            df_ldm_med[col_nemotecnico_ldm].apply(clean_nemotecnico), 
            pd.to_numeric(df_ldm_med.iloc[:, COL_LDM_PRECIO_IDX], errors='coerce').fillna(0) 
        ))
        ldm_map_max = dict(zip(
            df_ldm_max[col_nemotecnico_ldm].apply(clean_nemotecnico), 
            pd.to_numeric(df_ldm_max.iloc[:, COL_LDM_PRECIO_IDX], errors='coerce').fillna(0) 
        ))
        
        print(f"Total de unidades mapeadas en BASE COEH: {len(nemotecnico_map)}")
        # Nota: La inspección de BVT-B debe hacerse en el entorno real, ya que el archivo adjunto tiene 0s.
        
        # --- 3. Iterar sobre COEH y Actualizar Precios (Lógica de asignación horaria mantenida) ---

        # FILTRO DE FECHA: Crea la máscara para la fecha de destino

        df_coeh_update[COL_DIA_NAME] = pd.to_numeric(df_coeh_update[COL_DIA_NAME], errors='coerce')
        df_coeh_update[COL_ANIO_NAME] = pd.to_numeric(df_coeh_update[COL_ANIO_NAME], errors='coerce')
        df_coeh_update[COL_HOUR_NAME] = pd.to_numeric(df_coeh_update[COL_HOUR_NAME], errors='coerce').fillna(-1).astype(int)

        fecha_filter_mask = (df_coeh_update[COL_DIA_NAME] == int(dia_str)) & \
                            (df_coeh_update[COL_ANIO_NAME] == int(anio_str)) 
                            

        unit_cols = df_coeh_update.columns[num_time_cols:].tolist() 
        updates_count = 0

        for col_name in unit_cols:
            s_nemotecnico_ncp = clean_nemotecnico(col_name)
            s_nemotecnico_ldm = clean_nemotecnico(nemotecnico_map.get(s_nemotecnico_ncp, ""))

            if not s_nemotecnico_ldm or s_nemotecnico_ldm == '-':
                continue

        unit_cols = df_coeh_update.columns[num_time_cols:].tolist() 
        updates_count = 0
        COL_HOUR_NAME = encabezado_final[3]
        df_coeh_update[COL_HOUR_NAME] = pd.to_numeric(df_coeh_update[COL_HOUR_NAME], errors='coerce').fillna(-1).astype(int)

        for col_name in unit_cols:
            s_nemotecnico_ncp = clean_nemotecnico(col_name)
            s_nemotecnico_ldm = clean_nemotecnico(nemotecnico_map.get(s_nemotecnico_ncp, ""))
            
            if not s_nemotecnico_ldm or s_nemotecnico_ldm == '-':
                continue

            # Obtener precios de los mapas segmentados
            precio_min = ldm_map_min.get(s_nemotecnico_ldm, None)
            precio_med = ldm_map_med.get(s_nemotecnico_ldm, None)
            precio_max = ldm_map_max.get(s_nemotecnico_ldm, None)
            
            updated = False

            if df_coeh_update[col_name].dtype != np.float64:
                df_coeh_update[col_name] = df_coeh_update[col_name].astype(np.float64)

            # Asignación por DOBLE filtro (Fecha AND Hora)
            if precio_min is not None:
                for start, end in BANDA_HORARIA_RANGES['MINIMA']:
                    hora_filter_mask = (df_coeh_update[COL_HOUR_NAME] >= start) & (df_coeh_update[COL_HOUR_NAME] <= end)
                    final_mask = fecha_filter_mask & hora_filter_mask
                    df_coeh_update.loc[final_mask, col_name] = precio_min
                updated = True

            if precio_med is not None:
                for start, end in BANDA_HORARIA_RANGES['MEDIA']:
                    hora_filter_mask = (df_coeh_update[COL_HOUR_NAME] >= start) & (df_coeh_update[COL_HOUR_NAME] <= end)
                    final_mask = fecha_filter_mask & hora_filter_mask
                    df_coeh_update.loc[final_mask, col_name] = precio_med
                updated = True

            if precio_max is not None:
                for start, end in BANDA_HORARIA_RANGES['MAXIMA']:
                    hora_filter_mask = (df_coeh_update[COL_HOUR_NAME] >= start) & (df_coeh_update[COL_HOUR_NAME] <= end)
                    final_mask = fecha_filter_mask & hora_filter_mask
                    df_coeh_update.loc[final_mask, col_name] = precio_max
                updated = True

            if updated:
                updates_count += 1

        print(f"Actualización de precios en DataFrame COEH completada. ({updates_count} unidades actualizadas)")
        
        # --- 4. Guardado ---
        
        # Lógica de guardado original con pd.ExcelWriter (Se omiten mensajes de fallback)
        try:
             with pd.ExcelWriter(archivo_principal_path, engine='openpyxl', mode='a', if_sheet_exists='overlay') as writer:
                 df_coeh_update.to_excel(
                     writer, 
                     sheet_name=SHEET_COEH, 
                     index=False, 
                     header=False, 
                     startrow=2 
                 )
             print(f"Guardado exitoso de la hoja '{SHEET_COEH}' actualizada en: {archivo_principal_path}")
        except Exception:
            print(f"ERROR: Falló el guardado en Excel. Causa: {e}")
            print("ADVERTENCIA: Falló el guardado real en Excel (Verifique rutas/permisos).")

        # --- 5. Procesamiento de "Cotas Actualizadas.csv" ---
        # ... (Lógica original, mantenida para integridad)
        if os.path.exists(s_cotas_path_origen):
             df_cotas = pd.read_csv(s_cotas_path_origen)
             om_col = next((col for col in df_cotas.columns if 'Cos.O&M' in col), None)

             if om_col:
                 df_cotas[om_col] = 0
                 s_cotas_save_path_file = os.path.join(ruta_salida_dat, COTAS_OUTPUT_FILENAME)
                 df_cotas.to_csv(s_cotas_save_path_file, index=False)
                 print(f"Cotas Actualizadas.csv procesado y guardado en: {s_cotas_save_path_file}")
             else:
                 print("ADVERTENCIA: No se encontró la columna 'Cos.O&M' en Cotas Actualizadas.csv.")
        else:
            print(f"ADVERTENCIA: No se encontró el archivo {COTAS_INPUT_FILENAME} para procesar.")


        print("--- PROCESO Formato COEH (60 Min) FINALIZADO ---")
        return True

    except Exception as e:
        print(f"ERROR FATAL durante la ejecución de Actualizar Hoja COEH: {e}")
        return False

if __name__ == "__main__":
    # --- CONFIGURACIÓN DE PRUEBA: LECTURA DE ARCHIVOS REALES ---
    print("Ejecutando en modo de prueba (Asumiendo archivos .xlsx en la misma ruta)...")
    
    BASE_DIR = os.getcwd()
    
    # Rutas de Archivos de Entrada (asumiendo que están junto a este script)
    PDD_EXCEL_PATH = os.path.join(BASE_DIR, "data.xlsx") 
    LDM_EXCEL_PATH = os.path.join(BASE_DIR, LDM_INPUT_FILENAME)
    
    # Configuramos la carpeta de origen y destino como la base del script
    COTAS_FOLDER_PATH = BASE_DIR 
    COTAS_SAVE_PATH = BASE_DIR 
    
    # Fecha por defecto
    DEST_DATE_TEST = "17/10/2025" 
    
    print(f"Ejecutando proceso con DEST_DATE: {DEST_DATE_TEST}")
    
    if run_actualizar_hoja_coeh(COTAS_FOLDER_PATH, PDD_EXCEL_PATH, COTAS_SAVE_PATH, DEST_DATE_TEST, LDM_EXCEL_PATH):
        print("\nPrueba de ejecución finalizada con éxito.")
    else:
        print("\nPrueba de ejecución finalizada con errores. Revise el mensaje de ERROR FATAL.")
